##类层次结构

&emsp;&emsp;这里的问题在于：没有一种方式来区分所有形状的共有特征（例如，一个形状总有一种颜色，可以被画出来等），与某个特定形状种类的特殊特征（如圆是一种形状，它有一个半径，需要用画圆的函数画出等）。表达这种区分并由此获益就定义了面向对象的程序设计。具有能表达和利用这种区分的结构的语言将能支持面向对象的程序设计，其他语言就不行。

&emsp;&emsp;继承机制（是C++从Simula借来的）提供了一种解决方案。首先，我们描述一个定义了所有形状的共同特征的类：

```javascript
    class Shape {
        Point center;
        Color col;
        // ...
    public:
        Point where() { return center; }
        void move(Point to) { center = to; /* ... */ draw(); }
        
        virtual void draw() = 0;
        virtual void rotate(int angle) = 0;
        // ...
    };
```

就像在2.5.4节中的抽象类型Stack，所有提供了被定义的调用界面---但其实现却不能定义---的函数都是virtual。特别地，函数draw()和rotate()只能针对特定形状的语义去定义，所以它们被声明为virtual。

&emsp;&emsp;在给出这个定义之后，我们就可以写出函数，实现某种针对指向形状的指针向量的操作：

```javascript
    void rotate_all(vector<Shape*>& v, int angle)    // 将v的所有元素旋转angle度
    {
        for(int i = 0; i < v.size(); i++) v[i]->rotate(angle);
    }
```

要定义出一个特殊的形状，我们必须说明它是一个形状，并描述它的特殊性质（包括那些虚函数）：

```javascript
    class Circle : public Shape
    {
        int radius;
    public:
        void draw() { /* ... */ }
        void rotate(int) {}    // 的确，这是个空函数
    };
```

在C++里，类Circle被称为是由类Shape派生的，而类Shape被称为是类Circle的基类。关于Circle和Shape的另一对术语是子类和超类。我们还说派生类由其基类继承了成员，所以，对基类和派生类的使用通常也被说成是继承。