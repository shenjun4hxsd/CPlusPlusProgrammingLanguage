##具体类型的问题

&emsp;&emsp;一个具有类型就像通过模块定义的一个“假类型”一样，定义了一类黑盒子。一旦这种黑盒子定义好之后，它也就无法再与程序的其他部分进行实际地交互了：没有任何方式可以为了某些新的用途而调整它，除非去修改它的定义。这种情况可以认为是非常理想的，但也会导致严重缺乏灵活性。考虑在某个图形系统里定义一个类型Shape。假定当时这个系统需要支持圆形、三角形和正方形，再假定我们已经有了

    class Point{ /* ... */ };
    class Color{ /* ... */ };
    
这里的 /* 和 */ 分别表示一个注释的开始和结束，这种注释形式可以用于多行的注释，以及在一行结束之前结束的那种注释。

&emsp;&emsp;我们可能像下面这样定义形状（shape）类：

```javascript
    enum Kind { circle, triangle, square };
    class Shape {
        Kind k;        // 类型域
        Point center;
        Color col;
        // ...
    public:
        void draw();
        void rotate(int);
        // ...
    };
```

这里的“类型域”k是必需的，以便使draw()和rotate()一类的函数能够确定它们正在处理的是哪种形状（在类Pascal的语言里，人们可以使用带有标志k的变体纪录）。