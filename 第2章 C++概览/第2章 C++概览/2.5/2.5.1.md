##定义类型的模块

&emsp;&emsp;基于模块的程序设计趋向于以一个类型的所有数据为中心，在某个类型管理模块的控制之下工作。例如，如果我们希望有许多堆栈---而不是像前面那样只用一个由Stack模块提供的堆栈---我们就可能会定义一个堆栈管理器，它具有如下的界面：

```javascript
    namespace Stack
    {
        struct Pep;                // 在另外某个地方定义堆栈的布局
        typedef Rep& stack;
        
        stack create();            // 做出一个新堆栈
        void destroy(stack s);     // 删除s
        
        void push(stack s, char c);// 将c压入s
        char pop(stack s);         // 弹出s
    }
```

声明

    struct Rep;
    
说Rep是一个类型的名字，但将这个类型留待以后再去定义。声明

    typedef Rep& stack;
    
确定名字stack是“对Rep的引用”。这里的想法是，堆栈由Stack::stack表示，而进一步的细节则对用户隐藏起来。

&emsp;&emsp;一个Stack::stack用起来很像一个内部类型的变量：

```javascript
    struct Bad_pop { };
    
    void f()
    {
        Stack::stack s1 = Stack::create();    // 做出一个新堆栈
        Stack::stack s2 = Stack::create();    // 做出另一个新堆栈
        
        Stack::push(s1, 'c');
        Stack::push(s2, 'k');
        
        if(Stack::pop(s1) != 'c') throw Bad_pop();
        if(Stack::pop(s2) != 'k') throw Bad_pop();
        
        Stack::destroy(s1);
        Stack::destroy(s2);
    }
```

我们可以以几种不同的方式来实现这个堆栈。最重要的是，用户完全不必知道我们到底是怎么做的。只要我们能保持这个界面不改变，即使是决定重新实现Stack，用户也不会受到任何影响。

&emsp;&emsp;某个实现可以是预先分配几个堆栈，而让Stack::create()递交出到某个尚未使用的堆栈的引用。而Stack::destroy()则将一个堆栈表示标记为未使用的，以使Stack::create()能够重新用它

```javascript
    namespace Stack    // 表示
    {
        const int max_size = 200;
        
        struct Rep
        {
            char v[max_size];
            int top;
        };
        
        const int max = 16;    // 最大堆栈数
        Rep stacks[max];       // 预分配的堆栈表示
        bool used[max];        // 如果stacks[i]在使用, 则used[i]为真
        
        typedef Rep& stack;
    }
    
    void Stack::push(stack s, char c) { /* 检查s的上溢并压入c */ }
    char Stack::pop(stack s) { /* 检查s的下溢并弹出 */ }
    Stack::stack Stack::create()
    {
        // 找一个未使用的Rep, 将它标记为已使用的，将它初始化，并返回它的引用
    }
    void Stack::destroy(stack s) { /* 标记s为未使用的 */ }
```

我们