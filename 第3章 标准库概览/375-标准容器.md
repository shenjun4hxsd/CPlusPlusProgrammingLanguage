##标准容器

&emsp;&emsp;map、list或vector都可以用于表示一个电话簿。然而，它们中的每一个都有其长处和短处。例如，对向量的下标操作开销较小且易于操作，而另一方面，在向量的两个元素之间插入一个元素则是代价高昂的。list恰好具有与此相反的性质。map类似于（关键码，值）对偶的表，除此之外它还针对基于关键码去查询值做了特殊的优化。

&emsp;&emsp;标准库提供了一些最普通最常用的容器类型，这就使程序员可以选择某种能最好地满足其实际应用需要的容器：

|标准库容器的总结||
|:--|:--|
|vector< T>|变长向量（16.3节）|
|list< T>|双向链表（17.2.2节）|
|queue< T>|队列（17.3.2节）|
|stack< T>|堆栈（17.3.1节）|
|deque< T>|双端队列（17.2.3节）|
|priority_queue< T>|按值排序的队列（17.3.3节）|
|set< T>|集合（17.4.3节）|
|multiset< T>|集合，值可重复出现（17.4.4节）|
|map< key, value>|关联数组（17.4.1节）|
|multimap< key, value>|关联数组，关键字可重复出现（17.4.2节）|

标准容器将在16.2节、16.3节和第17章中讨论。这些容器都定义在名字空间std里，在< vector>、< list>、< map>等头文件里描述（16.2节）。

&emsp;&emsp;从记法的角度看，标准容器及其基本操作都被设计成相互类似的。进一步地，在不同容器里同样的操作的意义也是等价的。一般来说，许多基本操作适用于各种种类的容器。举例来说，push_back()能用于（以合理的效率）将一个元素加到一个vector或一个list的最后，每个容器都有一个size()成员函数，它们都返回容器中元素的个数。

&emsp;&emsp;这种记法和语义的一致性也使程序员可以提供新的容器类型，并使它们能按照与标准容器类似的方式使用。检查范围的向量Vec(3.7.2节)也就是这样的一个例子。第17章将展示如何把hash_map加入这个框架之中。容器界面的一致性还使我们能描述各种不依赖于任何特定容器类型的算法。

🔚