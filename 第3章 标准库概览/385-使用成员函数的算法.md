## 使用成员函数的算法

有许多算法都是将某个函数应用于一个序列里的各个元素。例如，在3.8.4节

```
for_each(ii, eos, record);
```

对输入的每个串调用 `record()`。

我们也经常需要处理指针的容器，而且实际希望的是对每个被指向的元素调用它的某个成员函数，而不是对指针去使用一个全局函数。例如，我们可能想对一个 `list<Shape*>` 里的每个元素调用成员函数 `Shape::draw()`。要处理这个特定例子，我们先简单写出一个非成员函数，让它去调用成员函数。例如，

```javascript
    void draw(Shape* p)
    {
        p->draw();
    }

    void f(list<Shape*>& sh)
    {
        for_each(sh.begin(), sh.end(), draw);
    }
```

通过将这种技术加以推广，我们就可以按如下方式写出这个例子：

```javascript
    void g(list<Shape*>& sh)
    {
        for_each(sh.begin(), sh.end(), mem_fun(&Shape::draw));
    }
```

标准库模版mem\_fun\(\)（18.4.4.2节）以一个到成员函数的指针（15.5节）为参数，产生出某种东西，使它可以对某个指向该成员所在的类的指针调用。这里mem\_fun\(&Shape::draw\)的结果就以Shape\*为参数，返回的就是Shape::draw\(\)返回的东西。

这种mem\_fun\(\)机制是非常重要的，因为它使各种标准算法能够被应用于保存多态对象的容器。

🔚

