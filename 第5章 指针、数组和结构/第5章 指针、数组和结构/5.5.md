##引用

&emsp;&emsp;一个引用就是某对象的另一个名字。引用的主要用途是为了描述函数的参数和返回值，特别是为了运算符的重载（第11章）。记法X&表示到X的引用。例如，

```javascript
    void f()
    {
        int i = 1;
        int& r = i;            // r和i现在引用同一个int
        int x = r;             // x = 1
        
        r = 2;                 // i = 2
    }
```

为了确保一个引用总能是某个东西的名字（也就是说，总能约束到某个对象），我们必须对引用做初始化。例如，

```javascript
    int i = 1;
    int& r1 = i;            // 正确：r1被初始化
    int& r2;                // 错误❌：没有初始化
    extern int& r3;         // 正确：r3在别处初始化
```

对一个引用的初始化是与对它赋值完全不同的另一件事情。除了外表形式之外，实际上根本就没有能操作引用的运算符操作。例如，

```javascript
    void g()
    {
        int ii = 0;
        int& rr = ii;
        rr++;                 // ii被增加1
        int* pp = &rr;        // pp指向ii
    }
```

这些都合法，但是rr++并没有对引用本身做什么增量操作；相反，++是应用到了那个int上，而这个int碰巧就是ii。因此，一个引用的值在初始化之后就不可能改变了，它总是引用它的初始化所指称的那个对象。要取得被引用rr所引用对象的地址，我们可以写&rr。

&emsp;&emsp;引用的一种最明显的实现方式是作为一个（常量）指针，在每次使用它时都自动地做间接访问。将引用想象成这种样子不会有任何问题，但要记住的是，一个引用并不是一个对象，不能像指针那样去操作。

在一些情况下，编译器可以通过优化去掉引用，使得在执行时根本不存在任何表示引用的东西。

&emsp;&emsp;当引用的初始式是一个左值时（是一个对象，你可以取得它的地址，见4.9.6节），其初始化就是非常简单的事情。对“普通”T&的初始式必须是一个类型T的左值。

对一个const T&的初始式不必是一个左值，甚至可以不是类型T的；在这种情况下：

1）、首先，如果需要将应用到T的隐式类型转换（见C.6节）。

2）、而后将结果存入一个类型T的临时变量。

3）、最后，将此临时变量用做初始式的值。

考虑

```javascript
    double& dr = 1;               // 错误❌：要求左值
    const double& cdr = 1;        // ok
```










