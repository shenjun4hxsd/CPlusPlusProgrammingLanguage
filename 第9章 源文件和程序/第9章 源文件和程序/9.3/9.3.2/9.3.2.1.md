##其他计算器模块

&emsp;&emsp;计算器的其他模块也可以用类似分析器的方式组织起来。然而，由于这些模块非常小，它们就没必要再有自己的 `_impl.h` 文件。只有在逻辑模块由许多函数组成，而它们又需要一个共享环境时，才需要使用这种头文件。

&emsp;&emsp;错误处理器已经缩减为一组异常类型，根本不需要error.c：

```javascript
    error.h:
    
    namespace Error {
        struct Zero_divide { };
        
        struct Syntax_error {
            const char* p;
            Syntax_error(const char* q) { p = q; }
        };
    }
```

词法处理器提供的是一个相当大的而且比较污浊的界面：

```javascript
    // lexer.h:
    
    namespace Lexer {
        enum Token_value {
            NAME,            NUMBER,            END,
            PLUS='+',        MINUS='-',         MUL='*',    DIV='\',
            PRINT=';',       ASSIGN='=',        LP='(',     RP=')'
        };
        
        extern Token_value curr_tok;
        extern double number_value;
        extern std::string string_value;
        
        Token_value get_token();
    }
```

除了 `lexer.h` 外，词法处理器的实现还依赖于 `error.h`、`<iostream>`，以及在 `<cctype>` 里声明的那些用于确定字符类别的函数：

```javascript
    // lexer.c:
    
    #include "lexer.h"
    #include "error.h"
    #include <iostream>
    #include <cctype>
    
    Lexer::Token_value Lexer::curr_bok;
    double Lexer::number_value;
    std::string Lexer::string_value;
    
    Lexer::Token_value Lexer::get_token(){ /* ... */ }
```
















