##单一头文件

&emsp;&emsp;对将一个程序划分成几个文件的最简单解决方案就是将所有定义放入合适数目的 `.c` 文件里，在一个头文件里声明这些 `.c` 文件之间通信所需要的类型，并让它们中的每个都#include该头文件。对于计算器程序而言，我们可以用5个 `.c` 文件 --- lexer.c、parser.c、table.c、error.c和main.c，用它们保存所有的函数和数据定义；再加上一个 `dc.h`，其中存储在不止一个 `.c` 文件里使用的所有名字和声明。

&emsp;&emsp;头文件 `dc.h` 看起来大致是下面的样子：

```javascript
    // dc.h:
    namespace Error {
        struct Zero_divide {};
        
        struct Syntax_error {
            const char* p;
            Syntax_error (const char* q) { p = q; }
        };
    }
    
    #include <string>
    namespace Lexer {
        enum Token_value {
            NAME,        NUMBER,        END,
            PLUS='+',    MINUS='-',     MUL='*',     DIV='/',
            PRINT=';',   ASSIGN='=',    LP='(',,     RP=')'
        };
        extern Token_value curr_tok;
        extern double number_value;
        extern std::string string_value;
        Token_value get_token();
    }
    
    namespace Parser {
        double prim(bool get);        // 处理初等项
        double term(bool get);        // 乘和除
        double expr(bool get);        // 加和减
        
        using Lexer::get_token;
        using Lexer::curr_tok;
    }
    
    #include <map>
    extern std::map<std::string, double> table;
    
    namespace Driver {
        extern int no_of_errors;
        extern std::istream* input;
        void skip();
    }
```

将关键字extern用在每个变量声明上，可以保证当我们用#include将 "dc.h" 包含到各个 `.c` 文件后，不会出现重复定义的情况。对应的定义可以在适当的 `.c` 文件中找到。

&emsp;&emsp;把实际代码放到一边，lexer.c大致是下面的样子

```javascript
    // lexer.c
    #include "dc.h"
    #include <iostream>
    #include <cctype>
    
    Lexer::Token_value Lexer::curr_tok;
    double Lexer::number_value;
    std::string Lexer::string_value;
    
    Lexer::Token_value Lexer::get_token() { /* ... */ }
```