##单一头文件

&emsp;&emsp;对将一个程序划分成几个文件的最简单解决方案就是将所有定义放入合适数目的 `.c` 文件里，在一个头文件里声明这些 `.c` 文件之间通信所需要的类型，并让它们中的每个都#include该头文件。对于计算器程序而言，我们可以用5个 `.c` 文件 --- lexer.c、parser.c、table.c、error.c和main.c，用它们保存所有的函数和数据定义；再加上一个 `dc.h`，其中存储在不止一个 `.c` 文件里使用的所有名字和声明。

&emsp;&emsp;头文件 `dc.h` 看起来大致是下面的样子：

```javascript
    // dc.h:
    namespace Error {
        struct Zero_divide {};
        
        struct Syntax_error {
            const char* p;
            Syntax_error (const char* q) { p = q; }
        };
    }
    
    #include <string>
    namespace Lexer {
        enum Token_value {
            NAME,        NUMBER,        END,
            PLUS='+',    MINUS='-',     MUL='*',     DIV='/',
            PRINT=';',   ASSIGN='=',    LP='(',,     RP=')'
        };
        extern Token_value curr_tok;
        extern double number_value;
        extern std::string string_value;
        Token_value get_token();
    }
    
    namespace Parser {
        double prim(bool get);        // 处理初等项
        double term(bool get);        // 乘和除
        double expr(bool get);        // 加和减
        
        using Lexer::get_token;
        using Lexer::curr_tok;
    }
    
    #include <map>
    extern std::map<std::string, double> table;
    
    namespace Driver {
        extern int no_of_errors;
        extern std::istream* input;
        void skip();
    }
```

将关键字extern用在每个变量声明上，可以保证当我们用#include将 "dc.h" 包含到各个 `.c` 文件后，不会出现重复定义的情况。对应的定义可以在适当的 `.c` 文件中找到。

&emsp;&emsp;把实际代码放到一边，lexer.c大致是下面的样子

```javascript
    // lexer.c
    #include "dc.h"
    #include <iostream>
    #include <cctype>
    
    Lexer::Token_value Lexer::curr_tok;
    double Lexer::number_value;
    std::string Lexer::string_value;
    
    Lexer::Token_value Lexer::get_token() { /* ... */ }
```

以这种方式使用头文件，就能保证在头文件中的每个声明都将在某个地方被包含到它的定义所在的文件里。例如，在编译lexer.c时，提交给编译器的将是

```javascript
    namespace Lexer {            // 来自dc.h
        // ...
        Token_value get_token();
    }
    // ...
    
    Lexer::Token_value Lexer::get_token(){ /* ... */ }
```

这就保证了编译器能够查出一个名字的类型描述之间不一致的情况。例如，假设get_token()被声明为返回Token_value，而定义为返回int，对lexer.c的编译将因为遇到了类型不匹配的错误而失败。如果缺少某个定义，连接器将捕捉到这个错误。如果缺少某个声明，就会有某个 `.c` 文件无法编译。

&emsp;&emsp;文件parser.c看起来像下面这样：

```javascript
    // parser.c:
    #include "dc.h"
    
    double Parser::prim(bool get) { /* ... */ }
    double Parser::term(bool get) { /* ... */ }
    double Parser::expr(bool get) { /* ... */ }
```

文件table.c看起来像下面这样：

```javascript
    // table.c:
    #include "dc.h"
    std::map<std::string, double> table;
```




















