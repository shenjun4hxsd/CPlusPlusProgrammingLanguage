##头文件

&emsp;&emsp;对同一个对象、函数、类等的所有声明的类型都必须一致。所以，递交给编译器的源代码以及后来被连接的东西也必须一致。要达到在不同编译单位中声明的一致性，有一种不完美但却比较简单的方法，那就是将包含界面信息的头文件通过#include包含到可执行代码和/或数据定义的源程序文件里。

&emsp;&emsp;#include机制是一种正文操作的概念，用于将源程序片段收集到一起，形成一个提供给编译的单位（文件）。指令

    #include "to_be_included"

将用文件to_be_included的内容取代这个#include所在的那一行。该文件的内容应该是C++源代码，因为编译器接着要去读它。

&emsp;&emsp;如果要包含标准库文件，那么就应该使用尖括号 `<` 和 `>` 而不是引号。例如，

    #include <iostream>            // 来自标准库包含目录
    #include "myheader.h"          // 来自当前目录

不幸的是，在一个包含指令中，`<>` 或 `""` 内部的空格也是有意义的：

    #include < iostream >          // 将无法找到<iostream>

当一个文件被包含到某处之后，每次都需要重新去编译它，这看起来是过分奢侈了。不过，在典型情况下被包含的文件里只有声明，没有需要编译器深入分析的代码。进一步说，许多现在C++实现都提供了对头文件的某种预编译形式，以尽可能减少反复编译同一个头文件所需要的工作。

&emsp;&emsp;作为一种经验法则，头文件里可以包括

|||
|:--|:--|
|命名名字空间|namespace N { /\* ... \*/ }|
|类型定义|struct Point { int x, y; }|
|模板声明|template`<class T>` class Z;|
|模板定义|template`<class T>` class V { /\* ... \*/ };|
|函数声明|extern int strlen(const char*);|
|在线函数定义|inline char get(char* p) { return \*p++; }|