##C和C++

C被选作C++的基础语言是因为它：

    1、是通用的、简洁的、相对低级的。
    2、适合用于大部分系统程序设计工作。
    3、可以在每个地方的任何系统上运行。
    4、适应于UNIX程序设计环境。
    
C有它的问题，但一个从空白出发设计的语言也必然会有一些问题，况且我们了解C的问题。更重要的是，从C出发已经使“带类的C”成了一个有用的工具（或许还比较笨拙），而且只是在开始想到要将类似Simula的类加到C上之后没几个月的时间。

&emsp;&emsp;随着C++的使用变得更加广泛，以及它所提供的覆盖和超越C的功能变得更加重要，关于是否还应该保持兼容性的问题又一再地被提出来。很清楚，如果抛弃C的某些传统就可以避免一些问题（参见，例如[Sethi，1981]）。这些都没有做，因为：

    1)、存在着成百万行的C代码可能从C++中获益，先决条件是不必将它们完全从C重写写成C++。
    2)、存在着成百万行用C写出的库函数和功能软件代码可以从C++程序里使用，或者在C++程序之上使用；先决条件是C++能够与C连接兼容，且在语法上与C类似。
    3)、存在着数以十万计的程序员了解C语言，只需要去学习C++新特征的使用，而不想去重新学习基础。
    4)、C++和C将在许多年中被同一些人用于同样的系统，因此其差异必须或者很小，或者是很大，以最大限度地减少错误和混乱的发生。
    
C++的定义已经做了许多修订，以保证任何同时在C和C++里合法的结构在两个语言中都具有同样的意义（除了少量例外；B.2节）。

&emsp;&emsp;C语言本身也在发展和演化，部分地是在C++开发的影响之下[Rosler，1984]。ANSI C标准[C，1990]就包含了从“带类的C”借去的函数声明语法。借鉴是双向的，例如void\*指针类型是为ANSI C发明的，但却在C++里第一次实现。正如本书的第一版所允诺的，C++的定义已经过修订，以去掉无缘无故的不兼容性。今天的C++比原来更加与C兼容了。这里的想法是让C++尽可能接近ANSI C---但又不过于接近[Koenig，1989]。百分之百的兼容性从来就不是目标，因为这将危害类型安全性以及用户类型与内部类型的平滑集成。

&emsp;&emsp;


🔚