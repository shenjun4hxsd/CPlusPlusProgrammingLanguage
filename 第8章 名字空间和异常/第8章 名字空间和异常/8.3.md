##异常

&emsp;&emsp;当一个程序是由一些相互分离的模块组成时，特别是当这些模块来自某些独立开发的库时，错误处理的工作就需要分成两个相互独立的部分：

    1)、一方报告出那些无法在局部解决的错误。
    2)、另一方处理那些在其他地方检查出的错误。

一个库的作者可以检查出运行时的错误，但一般说，他对于应该如何去做就没有什么主意了。库的使用者可能知道如何去处理某些错误，但却无法去检查它们---不要然用户就会在自己的代码里处理这些错误，而不会把它们留给库。

&emsp;&emsp;在计算器的例子里我们回避了这个问题，因为那里设计的是一个程序整体。在这样做时，我们就可能将错误处理问题放在整个程序的框架中考虑。但是，当我们将计算器程序的各个逻辑部分分开，放进各自的名字空间之后，我们就看到每个名字空间都要依赖于名字空间Error（8.2.2节），而Error里的错误处理又要依赖于各模块在错误出现后的恰当行为。现在假定我们并没有足够的自由，无法去整体地设计这个计算器，也不希望在Error和其他模块之间有过强的联系。让我们做一个相反的假定，假定我们在写分析器等的时候并不知道驱动程序可能怎样处理错误。

&emsp;&emsp;虽然error()非常简单，但它也包含了一种处理错误策略：

```javascript
    namespace Error {
        int no_of_errors;
        
        double error(const char* s)
        {
            std::cerr << "error: " << s << '\n';
            no_of_errors++;
            return 1;
        }
    }
```

函数error()写出一条错误信息，提供一个默认值，使调用它的程序能继续计算下去，并保存一个简单的错误状态轨迹。更重要的是，程序中的每个部分都知道error()的存在，知道如何去调用它，以及可以期望由它得到些什么。对于一个由分别开发的库组合起来的程序而言，假定这么多东西或许是太多了。

&emsp;&emsp;异常机制是C++中用于将错误报告与错误处理分离开的手段。在这一节里，我们要在把异常应用于计算器实例的环境中给出有关异常的简单描述。第14章将提供有关异常及其使用的更广泛的讨论。

🔚