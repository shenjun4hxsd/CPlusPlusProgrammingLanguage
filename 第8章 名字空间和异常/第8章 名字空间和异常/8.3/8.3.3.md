##在计算器中的异常

&emsp;&emsp;有了基本的异常处理机制，我们现在可以重做6.1节计算器的例子，将运行中所发现的错误的处理从计算器的基本逻辑中分离出来。这将导致一种程序组织结构，它更真实地反映了那些由互相分离的联系松散的部分构造出的程序的情况。

&emsp;&emsp;首先，可以删除error()。与此对应，分析器函数只知道发出错误信号所使用的类型：

```javascript
    namespace Error {
        struct Zero_divide { };
        
        struct Syntax_error {
            const char* p;
            Syntax_error(const char* q) { p = q; }
        };
    }
```

分析器检查三种语法错误

```javascript
    Lexer::Token_value Lexer::get_token()
    {
        using namespace std;            // 使用输入，isalpha()等（6.1.7节）
            // ...
            default:                    // NAME, NAME =, 或者错误
                if(isalpha(ch)) {
                    string_value = ch;
                    while(input->get(ch) && isalnum(ch)) string_value.push_back(ch);
                    input->putback(ch);
                    return curr_tok = NAME;
                }
                throw Error::Syntax_error("bad token");
    }
    
    double Parser::prim(bool get)        // 处理初等项
    {
        // ...
        case Lexer::LP:
        {
            double e = expr(true);
            if(curr_tok != Lexer::RP) throw Error::Syntax_error("')' expected");
            get_token();        // 吃掉 ')'
            return e;
        }
        case Lexer::END:
            return 1;
        default:
            throw Error::Syntax_error("primary expected");
    }
```


