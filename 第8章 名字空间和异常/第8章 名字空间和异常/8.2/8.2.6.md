##名字查找

&emsp;&emsp;一个取T类型参数的函数常常与T类型本身定义在同一个名字空间里。因此，如果在使用一个函数的环境中无法找到它，我们就去查看它的参数所在的名字空间。例如，

```javascript
    namespace Chrono {
        class Date { /* ... */ };
        
        bool operator==(const Date&, const std::string&);
        std::string format(const Date&);        // 做出字符串表示
        // ...
    }
    
    void f(Chrono::Date d, int i)
    {
        std::string s = format(d);              // Chrono::format()
        std::string t = format(i);              // 错误❌：在作用域里没有format(int)
    }
```

与显式地使用限定相比，这个查找规则能使程序员节省许多输入，而且又不会以使用指令（8.2.3节）那样的方式污染名字空间。这个规则对于运算符的运算对象（11.2.4节）和模板参数（C.13.8.4节）特别有用，因为在那里使用显式限定是非常麻烦的。