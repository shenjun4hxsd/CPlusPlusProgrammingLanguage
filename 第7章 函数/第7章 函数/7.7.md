##指向函数的指针

&emsp;&emsp;对于一个函数只能做两件事：调用它，或者取得它的地址。通过取一个函数的地址而得到的指针，可以在后面用于调用这个函数。例如，

```javascript
    void error(string s) { /* ... */ }
    void (*efct)(string);            // 指向函数的指针
    
    void f()
    {
        efct = &error;               // efct指向error
        efct("error");               // 通过efct调用error
    }
```

编译器知道efct是一个指针，并会去调用被指的函数。这也就是说，可以不写从指针得到函数的间接运算 \*。与此类似，取得函数地址的 & 也可以不写：

```javascript
    void (*f1)(string) = &error;     // ok
    void (*f2)(string) = error;      // 也可以：与&error意思一样
    
    void g()
    {
        f1("Vasa");                  // ok
        (*f1)("Mary Rose");          // 也可以
    }
```

在指向函数的指针的声明中也需要给出参数类型，就像函数声明一样。在指针赋值时，完整的函数类型必须完全匹配。例如，

```javascript
    void (*pf)(string);               // 指向void(string)
    void f1(string);                  // void(string)
    int f2(string);                   // int(string)
    void f3(int*);                    // void(int*)
    
    void f()
    {
        pf = &f1;                     // ok
        pf = &f2;                     // 错误❌：返回类型不对
        pf = &f3;                     // 错误❌：参数类型不对
        
        pf("Hera");                   // ok
        pf(1);                        // 错误❌：参数类型不对
        
        int i = pf("Zeus");           // 错误❌：void赋值给int
    }
```

无论直接调用函数或通过某个指针去调用函数，有关参数传递的规则都完全相同。

&emsp;&emsp;人们常常为了方便而为指向函数的指针类型定义一个名字，这样可以避免到处去写意义不太明显的语法形式。下面是来自UNIX系统头文件的一个例子：

```javascript
    typedef void (*SIG_TYP)(int);        // 取自<signal.h>
    typedef void (*SIG_ARG_TYP)(int);
    SIG_TYP signal(int, SIG_ARG_TYP);
```

指向函数的指针的数组常常很有用。例如，我的基于鼠标的编辑器里的菜单系统，就是利用指向函数的指针的数组实现的，这些函数表示各种各样的操作。这个系统的细节不可能在这里描述，但下面是其中的基本思想：

```javascript
    typedef void (*PF)();
    PF edit_ops[] = {            // 编辑操作
        &cut, &paste, &copy, &search
    };
    
    PF file_ops[] = {            // 文件管理
        &open, &append, &close, &write
    };
```

然后我们就可以定义并初始化一些指针，由它们去控制各种操作，通过关联于鼠标键的菜单去选择那些操作：

```javascript
    PF* button2 = edit_ops;
    PF* button3 = file_ops;
```

在一个完整的实现里，定义一个菜单项需要提供更多的信息。例如，必须在某个地方保存有关需要显示的字符串的一个描述。随着系统的使用，鼠标键的意义也可能随环境而频繁变化，这种变化就可以（部分地）通过修改按键所对应的指针来实现。当用户选择一个菜单项时，例如按键2的项目3，就会执行相关的操作：

    button2[2]();            // 调用按键2的第3个函数

要理解指向函数的指针的表达能力，一种方式就是试着去写这种代码而不用函数指针---也不用它们的更具良好行为的兄弟：虚函数（12.2.6节）。通过把新函数插入运算符表等方式，就可以在运行中修改这种菜单。在运行中构造出新菜单也同样非常容易。

&emsp;&emsp;指向函数的指针可以用于提供一种简单形式的多态性例程，即那种可以应用于许多不同类型的对象的例程：

```javascript
    typedef int (*CFT)(const void*, const void*);
    void ssort(void* base, size_t n, size_t sz, CFT cmp)
    /*
        对向量base的n个元素按照递增顺序排序，
        用由"cmp"所指的函数做比较，
        元素的大小是"sz"。
        
        Shell排序（Knuth, Vol 3, Pg84）
    */
    {
         for(int gap = n/2; gap > 0; gap /= 2)
             for(int i = gap; i < n; i++)
                 for(int j = i - gap; j >= 0; j-=gap) {
                     char* b = static_cast<char*>(base);    // 必须强制
                     char* 
                 }
                    
    }
```













