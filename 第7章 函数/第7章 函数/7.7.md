##指向函数的指针

&emsp;&emsp;对于一个函数只能做两件事：调用它，或者取得它的地址。通过取一个函数的地址而得到的指针，可以在后面用于调用这个函数。例如，

```javascript
    void error(string s) { /* ... */ }
    void (*efct)(string);            // 指向函数的指针
    
    void f()
    {
        efct = &error;               // efct指向error
        efct("error");               // 通过efct调用error
    }
```

编译器知道efct是一个指针，并会去调用被指的函数。这也就是说，可以不写从指针得到函数的间接运算 \*。与此类似，取得函数地址的 & 也可以不写：

```javascript
    void (*f1)(string) = &error;     // ok
    void (*f2)(string) = error;      // 也可以：与&error意思一样
    
    void g()
    {
        f1("Vasa");                  // ok
        (*f1)("Mary Rose");          // 也可以
    }
```

在指向函数的指针的声明中也需要给出参数类型，就像函数声明一样。在指针赋值时，完整的函数类型必须完全匹配。例如，

```javascript
    void (*pf)(string);               // 指向void(string)
    void f1(string);                  // void(string)
    int f2(string);                   // int(string)
    void f3(int*);                    // void(int*)
    
    void f()
    {
        pf = &f1;                     // ok
        pf = &f2;                     // 错误❌：返回类型不对
        pf = &f3;                     // 错误❌：参数类型不对
        
        pf("Hera");                   // ok
        pf(1);                        // 错误❌：参数类型不对
        
        int i = pf("Zeus");           // 错误❌：void赋值给int
    }
```
