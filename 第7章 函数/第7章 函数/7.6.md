##未确定数目的参数

&emsp;&emsp;对于有些函数而言，我们没办法确定在各个调用中所期望的所有参数的个数和类型。声明这种函数的方式就是在参数表的最后用省略号（...）结束，省略号表示“还可能有另外一些参数”。例如，

    int printf(const char* ...);
    
这描述的是C标准库函数printf()（21.8节），对它的一个调用至少必须有一个参数，一个char*，但是还可以有，也可以没有其他参数。例如，

```javascript
    printf("Hello, world!\n");
    printf("My name is %s %s\n", first_name, second_name);
    printf("%d + %d = %d\n", 2, 3, 5);
```

这样的函数必须依赖于一些编译时无法使用的信息去解释它的参数表。对于printf()而言，其第一个参数是个格式串，其中包含了一些特殊字符序列，这些字符使printf()能够正确地处理其他参数。%s表示“期待一个char*参数”，%d表示“期待一个int参数”。然而，一般来说，编译器是没有办法知道这些情况的，它不能保证所期待的参数真的就在那里，也无法保证某个参数具有合适的类型。例如，

```javascript
    #include <stdio.h>
    int main()
    {
        printf("My name is %s %s\n", 2);
    }
```

将能通过编译，但（在最好情况下）将导致某些看起来很奇怪的输出（请试一试）。

&emsp;&emsp;事情很清楚，如果一个参数没有声明，编译器就没有信息去对它执行标准的类型检查和转换。在这种情况下，一个char或short将作为int传递，float将作为double传递。这些做法未必是程序员所期望的。

&emsp;&emsp;一个设计良好的程序至多只需要极少的几个这种参数类型没有完全刻画的函数。在大部分情况下，我们都可以利用重载函数和使用默认参数的函数来处理类型检查的问题。如果没有这些机制，在一些情况下就无法刻画参数的类型。只有在那些参数数目和参数类型都有变化的情况下才需要省略号。省略号最常见的用途是描述C库函数的界面，这些都是在C++提供了替代方式之前做出来的：

```javascript
    int fprintf(FILE*, const char* ...);            // 取自<cstdio>
    int execl(const char* ...);                     // 取自UNIX头文件
```

在`<cstdarg>`里提供了一组标准的宏，专门用于在这种函数里访问未加描述的参数。现在考虑写一个出错函数，它有一个int参数指明错误的严重性，随后是任意个字符串。这里的想法是将各个词分别作为字符串参数传递，进而组合起这个错误信息。字符串参数列表的最后需要有一个指向char的空指针。

```javascript
    extern void error(int ...);
    extern char* itoa(int, char[]);        // 见6.6[17]
    
    const char* Null_cp = 0;
    
    int main(int argc, char* argv[])
    {
        switch(argc) {
            case 1:
                error(0, argv[0], Null_cp);
                break;
            case 2:
                error(0, argv[0], argv[1], Null_cp);
                break;
            default:
                char buffer[8];
                error(1, argv[0], "with", itoa(argc-1, buffer), "arguments", Null_cp);
        }
        // ... 
    }
```

函数itoa()返回它的整数参数的表示。















